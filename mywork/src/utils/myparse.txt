/*
 * @Author: hvinci
 * @Date: 2023-10-23 23:40:38
 * @LastEditors: hvinci
 * @LastEditTime: 2023-11-18 15:00:04
 * @Description: 将脚本转换为语法分析树
 * 
 * Copyright (c) 2023 by ${git_name_email}, All Rights Reserved. 
 */

import { AST ,SPEAK,LISTEN,SLIENCE,DEFAULT} from "./interface"

let astTree: AST;
let nowLine: number ;
let nowStep: string ;

/**
 * 分析脚本的语法树
 * @param script 
 * @returns 
 */
export function parse(script: string): AST {
    
    nowStep = "";
    nowLine = 1;

    //初始化
    initializeParser();

    // 判断输入是否为字符串
    checkInput(script);

    // 对代码按行解析
    parseScriptLines(script);

    // 验证语法树
    validate();

    return astTree;
}

/**
 * 初始化 
 */

function initializeParser() {
    astTree ={
        hash : {},
        entry:"",
        exit:"",
        variable : {},
    };
}

/**
 * 判断输入是否为字符串
 * @param script 
 */
function checkInput(script: string) {
    if (typeof script != "string") {
        throw new TypeError("Please use string （╯#-_-)╯╧═╧");
    }
}


/**
 * Parses the script line by line
 * @param script The script to be parsed
 */
function parseScriptLines(script: string) {
    const lines = script.split("\n");

    for (const line of lines.map(line => line.trim())) {
        if (line === "" || line.startsWith("#")) {
            continue;
        }

        parseByLine(line);
        nowLine++;
    }
}


/**
 * 解析脚本的每一行
 * @param line 
 */
function parseByLine(line: string) {
    // Extract strings from the line using a regex
    const stringRegex = (line.match(/"([^\\"\n]|\\.)*"/g) || []).map(str => str.substring(1, str.length - 1));

    // Replace all strings in the line with "string"
    line = line.replace(/"([^\\"\n]|\\.)*"/g, "string");

    // Split the line by spaces
    const tokens = line.split(" ");

    // Parse tokens
    parseToken(tokens, stringRegex);
}

/**
 * 解析token
 * @param tokens 
 * @param stringRegex 
 */
function parseToken(tokens: string[], strings: string[]) {
    //获取 token 的类型
    const type = tokens[0].toLowerCase();

    // 获取 token 的参数
    const args = tokens.slice(1).join(" ");
    console.log(args);
    console.log(strings);
    switch(type){
        case "step":
            parseStep(args);
            break;
        case "speak":
            parseSpeak(args, strings);
            break;
        case "listen":
            parseListen(args);
            break;
        case "branch":
            parseBranch(args, strings);
            break;
        case "silence":
            parseSilence(args);
            break;
        case "default":
            parseDefault(args);
            break;
        case "exit":
            parseExit();
            break;
        case "culculate":
            praseCulculate(args);
            break;
        default:
            console.log("token:",type);
            // 如果不是以上的 token 类型，则抛出异常
            throw new Error(
                "Your type must be one of step, speak, listen, branch, silence, default,or exit. At Line: " +
                    nowLine.toString()
            );
    }
}

/**
 * 处理step分支
 * 结构:step stepName
 * @param args 
 */
function parseStep(args: string) {
    // 分割参数
    const stepNames = args.split(" ");

    // 参数应该只有一个标识符
    if (stepNames.length == 0 || stepNames[0].length == 0) {
        throw new Error(
            "Each step must have one step name. At Line: " + nowLine.toString()
        );
    } else if (stepNames.length > 1) {
        throw new Error(
            "Each step can have only one step name. At Line: " +
                nowLine.toString()
        );
    }
    // 存入stepName 
    const stepName = stepNames[0];

    //行号
    astTree.hash[stepName] = {
        line: nowLine,
    };

    // 识别entry
    if (Object.keys(astTree.hash).length == 1) {
        astTree.entry = stepName;
    }

    // 设置当前解析的步骤
    nowStep = stepName;

    console.log(`Parsed Step: ${stepName} at Line: ${nowLine}`);
}

/**
 * 处理speak分支
 * @param args 
 * @param strings 
 */
function parseSpeak(args: string, strings: string[]) {
    args = args.replace(/\+/g, " ");
    const messages = args.split(" ");

    const speakInfo: SPEAK[] = [];
    let count = 0;

    for (const message of messages.map(msg => msg.trim())) {
        if (message === "string") {
            const arg = strings[count++];
            speakInfo.push({ type: "string", args: arg, lineNum: nowLine });
        } else if (message.startsWith("$")) {
            const variableName = message;
            speakInfo.push({ type: "var", args: variableName, lineNum: nowLine });
            astTree.variable[variableName] = "";
        } else if (message.startsWith("#")) {
            break;
        } else if (message.length > 0) {
            throw new Error(`Expected string or variable. At Line: ${nowLine}`);
        }
    }
    

    astTree.hash[nowStep].speak = speakInfo;

    console.log(`Parsed Speak at Line: ${nowLine}`);
}
/**
 * 处理listen分支
 * listen 时间
 * @param args 
 * @param strings 
 */
function parseListen(args: string): void {
    const time = parseInt(args);

    if (isNaN(time)) {
        throw new Error(`Expected time to be a number. At Line: ${nowLine}`);
    }

    const listenInfo: LISTEN = {
        limit: time,
        lineNum: nowLine,
    };

    astTree.hash[nowStep].listen = listenInfo;

    console.log(`Parsed Listen at Line: ${nowLine}`);
}

/**
 * 处理branch分支
 * @param args 
 * @param strings 
 */
function parseBranch(args: string, strings: string[]): void {
    const [answer, stepID] = args.split(",").map((item) => item.trim());

    if (!answer || !stepID) {
        throw new Error(`You must give branch two args. At Line: ${nowLine}`);
    }

    if (typeof answer !== "string") {
        throw new Error(`Your branch must have an answer string. At Line: ${nowLine}`);
    }

    const branchInfo = astTree.hash[nowStep].branch || [];
    branchInfo.push({
        answer: strings[0].trim(),
        stepID,
        lineNum: nowLine,
    });

    astTree.hash[nowStep].branch = branchInfo;

    console.log(`Parsed Branch at Line: ${nowLine}`);
}


/**
 * 处理silence分支
 * 只有一个silence
 * @param args 
 */
function parseSilence(args: string) {

    // 如果参数个数不是 1，则抛出异常
    if (args.split(" ").length != 1) {
        throw new Error(
            "Your silence must have one step. At Line: " + nowLine.toString()
        );
    }

    const silenceInfo: SLIENCE = {
        stepID: args, 
        lineNum: nowLine
    }
    // 将 stepId 加入到 silence 列表中
    astTree.hash[nowStep].silence = silenceInfo;

    console.log(`Parsed Silence at Line: ${nowLine}`);
}

/**
 * default分支
 * 只有一个default
 * @param args 
 */
function parseDefault(args: string) {
    // 如果参数个数不是 1，则抛出异常
    if (args.split(" ").length != 1) {
        throw new Error(
            "Your default must have one step. At Line: " + nowLine.toString()
        );
    }
    const defaultInfo : DEFAULT = {
        stepID: args, 
        lineNum: nowLine
    }
    // 将 stepId 加入到 default 列表中
    astTree.hash[nowStep].default =defaultInfo;

    console.log(`Parsed Default at Line: ${nowLine}`);
}

/**
 * 处理exit分支
 */
function parseExit() {

    // 将 stepId 加入到 exit 列表中
    astTree.exit = nowStep;

    console.log(`Parsed Exit at Line: ${nowLine}`);
}



function praseCulculate(args: string): void {
    args = args.replace(/#.*$/, "");
    const [arg1, arg2, arg3] = args.split(",").map((item) => item.trim());

    const culculate = astTree.hash[nowStep].calculate || ([] as string[][]);

    culculate.push([arg1, arg2, arg3]);

    astTree.hash[nowStep].calculate = culculate;

    console.log(`Parsed Calculate at Line: ${nowLine}`);
}


export function validate(astToValidate: AST = astTree): void {
    // Check if the script tree is empty
    if (Object.keys(astToValidate.hash).length === 0) {
        throw new Error("Expected at least one step");
    }

    // Check if the exit list in the script tree has at least one exit step
    if (astToValidate.exit.length === 0) {
        throw new Error("Expected at least one exit step");
    }

    console.log("Validating each step in the script tree:");

    // Validate each step in the script tree
    for (const [stepId, step] of Object.entries(astToValidate.hash)) {
        console.log(`Validating Step: ${stepId} at Line: ${step.line?.toString() || 'unknown'}`);

        const { default: defaultList, silence, listen, branch, line } = step;

        // Validate default step conditions
        if (!defaultList && !astToValidate.exit.includes(stepId) && !step.calculate) {
            throw new Error(`Expected default step. At Line: ${line?.toString() || 'unknown'}`);
        } else if (defaultList && !Object.keys(astToValidate.hash).includes(defaultList.stepID)) {
            throw new Error(`Default step ${defaultList.stepID} is invalid. At Line: ${defaultList.lineNum?.toString() || 'unknown'}`);
        }

        // Validate silence step
        if (silence && !Object.keys(astToValidate.hash).includes(silence.stepID)) {
            throw new Error(`Silence step ${silence.stepID} is invalid. At Line: ${silence.lineNum?.toString() || 'unknown'}`);
        }

        // Validate listen time
        if (listen && listen.limit <= 0) {
            throw new Error(`Listen time is invalid. At Line: ${listen.lineNum?.toString() || 'unknown'}`);
        }

        // Validate branch steps
        if (branch) {
            for (const { stepID, lineNum } of branch) {
                if (!Object.keys(astToValidate.hash).includes(stepID)) {
                    throw new Error(`Branch step ${stepID} is invalid. At Line: ${lineNum?.toString() || 'unknown'}`);
                }
            }
        }
    }

    console.log("Validation successful!");
}
